学习笔记
## 一、学习内容

1. 哈希表、映射、集合

2. 树、二叉树、二叉搜索树
(1) 重点：树的前序遍历、中序遍历、后序遍历、层次遍历。

3. 堆、二叉堆、图

(1) heap：可以迅速找到一堆数中的最大值或最小值的数据结构。根节点最大的堆叫大顶堆或大根堆，根节点最小的堆叫小顶堆或小根堆。常见的堆有二叉堆、斐波那契堆。

(2) 二叉堆性质：二叉堆通过完全二叉树来实现。
    二叉堆(大顶)满足以下性质：1）是一颗完全二叉树。 2）树中任意节点的值大于等于其子节点的值。

(3) 二叉堆实现：一般直接通过数组实现，因为其是完全二叉树。Java 优先队列(PriorityQueue)使用了这种数据结构，如果想使用二叉堆，可直接通过借用 PriorityQueue 来使用。
    数组从索引 0 开始，则父节点和子节点的位置关系如下：
    索引为 i 的左孩子的索引是 (2 * i + 1);
    索引为 i 的右孩子的索引是 (2 * i + 2);
    索引为 i 的父节点的索引是 floor((i - 1) / 2);

(4) 二叉堆的插入(O(logN))：1）新元素一律插入到堆的尾部。 2）将新元素依次向上调整直到符合它的值大小的合适位置(HeapifyUp())。

(5) 二叉堆的删除(O(logN))：1）将堆尾元素替换到顶部。 2）将顶部元素依次向下调整直到符合它的值大小的合适位置(HeapifyDown())。
    
(6) 图的属性：
- Graph（V,E）
- V-vertex：点  
1.入度和出度  
2.点与点之间是否连通
- E-edge:边  
1.有向和无向(单行线)  
2.权重(边长)  
        
## 二、做题时使用的解题技巧
1. 利用递归解决树的前序遍历、中序遍历、后续遍历。
2. 利用队列解决树的层次遍历。
3. 借助优先队列(PriorityQueue)来使用二叉堆解决获取最大值、最小值、前 N 个最大/最小值问题。
4. 有些题目算法实现过程结果需要存放到 List 中，并且最终返回的结果是跟算法存放的顺序相反的，那么可以使用 LinkedList 来存放，存放时使用 list.add(0, node);

## 三、HashMap 源码分析(基于 Java 1.8.0_201)
1. 数据结构：
- Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;    
    V value;
    Node<K,V> next;
}
- Node<K,V>[] table：HashMap 采用数组 + 链表/红黑树的方式存储元素，当链表的结点数大于等于7时，转换为红黑树。

2. put() 操作分析

(1) 首先计算((n - 1) & hash)求出当前节点应该存放在 table 数组的索引位置。如果该位置当前为空，直接将结点放到此位置。

(2) 如果不为空，判断当前位置的结点是否与新插入的结点 key 相同。如果是，取得该结点。

(3) 如果不是，判断该结点下是链表结构还是红黑数结构，如果是红黑树，调用 putTreeVal 方法去获取相同 key 的结点或者插入新的结点。

(4) 如果是链表结构，遍历该链表，看是否有相同 key 的结点，有则获取到该结点，如果没有，则在链表末尾插入新的结点，并且发现插入后结点大于等于7时，将当前链表转换为红黑树。

(5) 如果前三步操作中，能够找到相同 key 的结点，则将该结点赋新的值，并返回旧值。如果不能，则将当前记录结点大小的 size + 1，并判断是否需要扩容，最后返回 null。

3. get(key) 操作分析

(1) 首先计算((n - 1) & hash)求出指定 key 应该存放在 table 数组的索引位置，获取到该位置上的第一个结点。

(2) 判断第一个结点的 key 是否与指定 key 相同，相同则返回该结点。

(3) 否则，判断该结点下是链表结构还是红黑树结构，如果是红黑树，调用 getTreeNode 方法去查找指定 key 的结点。

(4) 如果不是，遍历链表，查找相同 key 的结点。

(5) 如果最终没找到，返回 null。
